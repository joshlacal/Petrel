{%- for prop in properties %}
        public let {{ prop.name }}: {{ prop.type }}{% if prop.optional %}?{% endif %}
        {%- endfor %}

        // Standard initializer
        public init({% for prop in properties -%}
                    {{ prop.name }}: {{ prop.type }}{% if prop.optional %}?{% endif %}{% if not loop.last %}, {% endif %}
                    {%- endfor %}) {
            {% for prop in properties %}
            self.{{ prop.name }} = {{ prop.name }}
            {% endfor %}
        }

        // Codable initializer
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            {%- for prop in properties %}
            {% if prop.optional %}
            self.{{ prop.name }} = try container.decodeIfPresent({{ prop.type }}.self, forKey: .{{ prop.name }})
            {% else %}
            self.{{ prop.name }} = try container.decode({{ prop.type }}.self, forKey: .{{ prop.name }})
            {% endif %}
            {%- endfor %}
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            // Encode the $type field
            try container.encode(Self.typeIdentifier, forKey: .typeIdentifier)
            {%- for prop in properties %}
            {% if prop.optional %}
            if let value = {{ prop.name }} {
                {% if '[' in prop.type and ']' in prop.type %}
                if !value.isEmpty {
                    try container.encode(value, forKey: .{{ prop.name }})
                }
                {% else %}
                try container.encode(value, forKey: .{{ prop.name }})
                {% endif %}
            }
            {% else %}
            try container.encode({{ prop.name }}, forKey: .{{ prop.name }})
            {% endif %}
            {%- endfor %}
        }
                                            
        public static func == (lhs: Self, rhs: Self) -> Bool {
            return lhs.isEqual(to: rhs)
        }

        public func isEqual(to other: any ATProtocolValue) -> Bool {
            guard let other = other as? Self else { return false }
            {%- for prop in properties %}
            {% if prop.optional %}
            if {{ prop.name }} != other.{{ prop.name }} {
                return false
            }
            {% else %}
            if self.{{ prop.name }} != other.{{ prop.name }} {
                return false
            }
            {% endif %}
            {%- endfor %}
            return true
        }
        
        public func hash(into hasher: inout Hasher) {
            {%- for prop in properties %}
            {%- if prop.optional %}
            if let value = {{ prop.name }} {
                hasher.combine(value)
            } else {
                hasher.combine(nil as Int?) // Placeholder for nil
            }
            {%- else %}
            hasher.combine({{ prop.name }})
            {%- endif %}
            {%- endfor %}
        }

        // DAGCBOR encoding with field ordering
        public func toCBORValue() throws -> Any {
            var map = OrderedCBORMap()
            
            // Always add $type first (AT Protocol convention)
            map = map.adding(key: "$type", value: Self.typeIdentifier)
            
            // Add remaining fields in lexicon-defined order
            {% for prop in properties %}
            {% if prop.optional %}
            if let value = {{ prop.name }} {
                {% if '[' in prop.type and ']' in prop.type %}
                if !value.isEmpty {
                    {% set var_name = prop.name + 'Value' %}
                    let {{ var_name }} = try (value as? DAGCBOREncodable)?.toCBORValue() ?? value
                    map = map.adding(key: "{{ prop.name }}", value: {{ var_name }})
                }
                {% else %}
                {% set var_name = prop.name + 'Value' %}
                let {{ var_name }} = try (value as? DAGCBOREncodable)?.toCBORValue() ?? value
                map = map.adding(key: "{{ prop.name }}", value: {{ var_name }})
                {% endif %}
            }
            {% else %}
            {% set var_name = prop.name + 'Value' %}
            let {{ var_name }} = try ({{ prop.name }} as? DAGCBOREncodable)?.toCBORValue() ?? {{ prop.name }}
            map = map.adding(key: "{{ prop.name }}", value: {{ var_name }})
            {% endif %}
            {% endfor %}
            
            return map
        }

        private enum CodingKeys: String, CodingKey {
            case typeIdentifier = "$type"
            {%- for prop in properties %}
            case {{ prop.name }}
            {%- endfor %}
        }
