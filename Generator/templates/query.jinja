{% if output_encoding == "text/event-stream" %}
extension ATProtoClient.{{ template_namespace_name }} {
    // MARK: - {{ query_name | lowerCamelCase }}

    /// {{ description }}
    /// {% if input_struct_name %}
    /// - Parameter input: The input parameters for the request
    /// {% endif %}
    /// - Returns: AsyncThrowingStream of events from the Server-Sent Events stream
    /// - Throws: NetworkError if the request fails or the connection cannot be established
    public func {{ query_name | lowerCamelCase }}({% if input_struct_name %}input: {{ input_struct_name }}{% endif %}) async throws -> AsyncThrowingStream<{{ output_type }}, Error> {
        let endpoint = "{{ endpoint }}"

        {% if input_struct_name %}
        let queryItems = input.asQueryItems()
        {% else %}
        let queryItems: [URLQueryItem]? = nil
        {% endif %}
        let urlRequest = try await networkService.createURLRequest(
            endpoint: endpoint,
            method: "GET",
            headers: ["Accept": "{{ output_encoding }}"],
            body: nil,
            queryItems: queryItems
        )

        // Determine service DID for this endpoint
        let serviceDID = await networkService.getServiceDID(for: "{{ endpoint }}")
        let proxyHeaders = serviceDID.map { ["atproto-proxy": $0] }

        return AsyncThrowingStream { continuation in
            Task {
                do {
                    // Use networkService to prepare authenticated streaming request with OAuth/DPoP
                    let authenticatedRequest = try await networkService.prepareStreamingRequest(
                        urlRequest,
                        additionalHeaders: proxyHeaders
                    )

                    // Create URLSession with infinite timeouts for SSE long-lived connections
                    let configuration = URLSessionConfiguration.default
                    configuration.timeoutIntervalForRequest = .infinity
                    configuration.timeoutIntervalForResource = .infinity
                    configuration.waitsForConnectivity = true
                    let sseSession = URLSession(configuration: configuration)

                    let (bytes, response) = try await sseSession.bytes(for: authenticatedRequest)

                    guard let httpResponse = response as? HTTPURLResponse else {
                        continuation.finish(throwing: NetworkError.invalidResponse(description: "Non-HTTP response"))
                        return
                    }

                    guard httpResponse.statusCode == 200 else {
                        continuation.finish(throwing: NetworkError.serverError(code: httpResponse.statusCode, message: "SSE connection failed"))
                        return
                    }

                    guard let contentType = httpResponse.allHeaderFields["Content-Type"] as? String,
                          contentType.lowercased().contains("text/event-stream") else {
                        continuation.finish(throwing: NetworkError.invalidContentType(expected: "text/event-stream", actual: httpResponse.allHeaderFields["Content-Type"] as? String ?? "nil"))
                        return
                    }

                    // Parse SSE stream
                    var buffer = ""
                    let decoder = JSONDecoder()

                    for try await byte in bytes {
                        let char = Character(UnicodeScalar(byte))
                        buffer.append(char)

                        // SSE events are delimited by double newline
                        if buffer.hasSuffix("\n\n") {
                            // Parse the event
                            let lines = buffer.split(separator: "\n", omittingEmptySubsequences: false)

                            for line in lines {
                                let lineStr = String(line)

                                // SSE data lines start with "data: "
                                if lineStr.hasPrefix("data: ") {
                                    let jsonString = String(lineStr.dropFirst(6))

                                    if let jsonData = jsonString.data(using: .utf8) {
                                        do {
                                            let event = try decoder.decode({{ output_type }}.self, from: jsonData)
                                            continuation.yield(event)
                                        } catch {
                                            LogManager.logError("Failed to decode SSE event for {{ endpoint }}: \(error)")
                                            // Continue processing other events
                                        }
                                    }
                                }
                                // Ignore comment lines (start with ":") and other SSE fields
                            }

                            buffer = ""
                        }
                    }

                    // Stream ended normally
                    continuation.finish()
                } catch {
                    continuation.finish(throwing: error)
                }
            }
        }
    }
}
{% else %}
extension ATProtoClient.{{ template_namespace_name }} {
    // MARK: - {{ query_name | lowerCamelCase }}

    /// {{ description }}
    /// {% if input_struct_name %}
    /// - Parameter input: The input parameters for the request
    /// {% endif %}
    /// - Returns: A tuple containing the HTTP response code and the decoded response data
    /// - Throws: NetworkError if the request fails or the response cannot be processed
    public func {{ query_name | lowerCamelCase }}({% if input_struct_name %}input: {{ input_struct_name }}{% endif %}) async throws -> (responseCode: Int, data: {{ output_type }}?) {
        let endpoint = "{{ endpoint }}"

        {% if input_struct_name %}
        let queryItems = input.asQueryItems()
        {% else %}
        let queryItems: [URLQueryItem]? = nil
        {% endif %}
        let urlRequest = try await networkService.createURLRequest(
            endpoint: endpoint,
            method: "GET",
            headers: ["Accept": "{{ output_encoding }}"],
            body: nil,
            queryItems: queryItems
        )

        // Determine service DID for this endpoint
        let serviceDID = await networkService.getServiceDID(for: "{{ endpoint }}")
        let proxyHeaders = serviceDID.map { ["atproto-proxy": $0] }
        let (responseData, response) = try await networkService.performRequest(urlRequest, skipTokenRefresh: false, additionalHeaders: proxyHeaders)
        let responseCode = response.statusCode

        guard let contentType = response.allHeaderFields["Content-Type"] as? String else {
            throw NetworkError.invalidContentType(expected: "{{ output_encoding }}", actual: "nil")
        }

        if !contentType.lowercased().contains("{{ output_encoding.lower() }}") {
            throw NetworkError.invalidContentType(expected: "{{ output_encoding }}", actual: contentType)
        }

        // Only decode response data if request was successful
        if (200...299).contains(responseCode) {
            do {
                {% if output_encoding == "application/json" %}
                let decoder = JSONDecoder()
                let decodedData = try decoder.decode({{ output_type }}.self, from: responseData)
                {% elif output_encoding in ["*/*", "application/vnd.ipld.car", "application/jsonl"] %}
                let decodedData = {{ output_type }}(data: responseData)
                {% else %}
                let decodedData = {{ output_type }}(data: responseData)
                {% endif %}
                return (responseCode, decodedData)
            } catch {
                // Log the decoding error for debugging but still return the response code
                LogManager.logError("Failed to decode successful response for {{ endpoint }}: \(error)")
                return (responseCode, nil)
            }
        } else {
            {% if has_errors %}// Try to parse structured error response
            if let atprotoError = ATProtoErrorParser.parse(
                data: responseData,
                statusCode: responseCode,
                errorType: {{ struct_name }}.Error.self
            ) {
                throw atprotoError
            }
            {% endif %}
            // If we can't parse a structured error, return the response code
            // (maintains backward compatibility for endpoints without defined errors)
            return (responseCode, nil)
        }
    }
}
{% endif %}
